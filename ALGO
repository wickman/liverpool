Color:
  Club/Spade/Heart/Diamond


Rank:
  2-14


Card:
  .color [Club, Spade, Heart, Diamond]
  .rank  [2-10, 11[J], 12[Q], 13[K], 14[A]]
  [None ==> wildcard; .color=None, .rank=None ==> JOKER]

  iter_rank(...):
    create an iterator starting at Card and iterate until Ace


Hand
  .setdices [counters for each rank] (|L|=15)
  .rundices[color] [contiguous run vectors, |L|=15]


Run
  .start=Card (fully specified, never joker)
  .jokers = boolean array of joker or not (length = length of run)


Set
  .rank=Rank
  .colors=[Color array, None for JOKER]


.put_card(Card) => increment indices
.put_run => translate into put_cards
.put_set => translate into put_cards

.take_card(Card) => decrement indices
.take_run => translate into take_cards
.take_set => translate into take_cards

raise UnavailableError if cannot take


if adding a card to a hand:
  - increment setdex
  - update rundex


how to generate candidate runs and sets?

for rank, dim_max in enumerate(self.setdex):
  for dim in range(3, dim_max + 1):
    for card_set in CardSet(self.filter(rank)).choose(dim):
      yield Set(rank, card_set.colors())

sets:
  if jokers, increment all setdices by #jokers in range(0, #jokers+1)
    given a setdex >= 3:
      for each dimension in range(3, dim+1)
        yield all combinations of holding sets in rank/dimension

runs:
  increment all rundices by #jokers

  runs = []

  for each nonzero rundex element:
    start = element
    run = Run(start)

    while True:
      try:
        card = take_card(start)
        start.incr()
        run.append(card)
      except InvalidTake:
        undo(run)
        break
      if run.valid:
        runs.append(run.dup())

  run_jokers = []
  iterate through each rundex:
    card = take_card(rundex card)


# 3 jokers + lots of cards =
#     2300 runs
#     3000 sets



let's assume for a moment that we can generate all sets and runs
we still need to be able to generate all combinations of sets and runs
which will look like the following:

Strategy(object):
  runs = int
  sets = int


# the challenge here is that it should be possible to take two of identical
# runs -- e.g. if you have two 7-10 spades runs, you can play each.
#
# this might mean codifying the rank of the cards
#
# e.g. if you have 2 7H, they should be identified as (0,7H), (1,7H)  (!dingdingding)
#
# in practice though (0,7H),(0,7S),(0,7D) should be interoperable with
# (1,7H),(0,7S),(0,7D)
#
# this only really matters for take() operations.  should we care?  are we
# prematurely optimizing? (probably)
#
# it seems like for sets, this distinction is superfluous
# for run _generation_ it could possibly matter
#
# so could it for sets, technically speaking, because you could have 7HSD + 7HSD


for run_comb in set(itertools.combinations(runs, run_dim)):
  for set_comb in set(itertools.combinations(sets, set_dim)):
    yield run_comb, set_comb


# The way to get around this is to just generate all possibilities,
# unenumerated, then with all_sets, all_runs, when you select one for
# consideration, you do not remove it from all_sets (so that each could be
# considered in duplicate.)


-------

JOKERS = 0

I think we need to precompute these


right rundex
. . . | . | . . . | . | . . | . . . . .
0 1 1 2 1 1 0 1 1 2 1 1 1 1 1 0 0 0 0 0   -- 0 JOKERS :: 0 3-len
1 2 2 3 2 2 1 2 2 3 2 2 2 2 2 1 1 1 1 1   -- 1 JOKERS :: 2 3-len
2 3 3 4 3 3 2 3 3 4 3 3 3 3 3 2 2 2 2 2   -- 2 JOKERS :: 14 3-len, 2 4-len

      * from this spot we can do runs of length 3 or 4
      runs of length 3: 3 ? 5 6, ? ? 5, 3 ? ?
      runs of length 4: 3 ? 5 ?

    * from this spot we can do runs of length 3 (but really 4!)




vary:
  length
    num_jokers


the challenge is that if we have 3 ? 5, with spare jokers, we need to also try combinations of 3,5,?
if we have 2 more jokers, then 3,5,?,?

we can actually do this w/o using the rundex at all, theoretically




left rundex
. . . | . | . . . | . | . . | . . . . .
0 0 0 1 1 2 1 1 0 1 1 2 1 1 1 1 1 0 0 0   -- the rundex can be considered Run.MIN - # of jokers necessary to do a left run
1 1 1 2 2 3 2 2 1 2 2 3 2 2 2 2 2 1 1 1
2 2 2 3 3 4 3 3 2 3 3 4 3 3 3 3 3 2 2 2


for joker_count in range(0, jokers + 1):
  for run_start, run_sum in enumerate(rundex):
    if run_sum + joker_count



# this should be done with bitvectors

find_gaps:
  gap_start = 0
  gap = -1
  for elt_index, elt in enumerate(rundex):
    if elt:
      for k in range(max(0, elt_index - jokers), min(len(rundex), elt_index + jokers + 1)):
        if rundex[k] == 0:
          rundex[k] = 1


# derpderpderp

assume we have 3 5 6 and 1 joker:
       3 ? 5 6

with 2 jokers:
       3 ? 5 6 + ? ==>

       [3, 5, 6, ?, ?] c 4 =>
          3 5 6 ?


      0 1 2 3 4 5 6 7 8 9 0 J Q K A
      . . . | | | | | . | . | . . |
1-sum 0 0 0 1 1 1 1 1 0 1 0 1 0 0 1
2-sum 0 0 1 2 2 2 2 1 1 1 1 1 0 1 1
3-sum 0 1 2 3 3 3 2 2 1 2 1 1 1 1 1
4-sum 1 2 3 4 4 3 3 2 2 2 1 2 1 1 1
5-sum 2 3 4 5 4 4 3 3 2 2 2 2 1 1 1
6-sum 3 4 5 5 5 5 4 3 2 3 2 2 1 1 1

discounted

      0 1 2 3 4 5 6 7 8 9 0 J Q K A
      . . . | | | | | . | . | . . |
1-sum 1 1 1 0 0 0 0 0 1 0 1 0 1 1 0
2-sum 2 2 1 0 0 0 0 1 1 1 1 1 2 1 1
3-sum 3 2 1 0 0 0 1 1 2 1 2 2 2 2 2
4-sum 3 2 1 0 0 1 1 2 2 2 3 2 3 3 3
5-sum 3 2 1 0 1 1 2 2 3 3 3 3 4 4 4
6-sum 3 2 1 1 1 1 2 3 4 3 4 4 5 5 5

      0 1 2 3 4 5 6 7 8 9 0 J Q K A
      . . . | | | | | . | . | . . |
0-jok 0 0 0 5 4 3 2 1 0 1 0 1 0 0 1
1-jok 1 1 6 7 6 5 4 3 2 3 2 2 1 1 1
2-jok 2 7 8 9 8 7 6 5 4 4 3 4 3 2 1
3-jok 8 9 A A 9 8 7 6 5 6 5 4 3 2 1
4-jok
5-jok
6-jok


start at 3
you have 2 jokers
this means you can generate run length 9


# from a spot, we can iter over the following tuples:
#   (run_length, jokers_required)
#
# 3 . 5 6 . .
#
# (4, 1)
# (5, 2)
# (6, 3) etc
#
# for run_start, rundex_value in rundex:
#   for run_length in range(Run.MIN,
#   necessary_jokers =
#   for used_jokers in range(0, num_jokers + 1):
#     run_length = rundex_value + used_jokers
#     if run_length < Run.MIN:
#       continue
#

---------------------------------

13 cards -> 4096 possibilities
for each of 0..6 jokers, enumerate possible run combinations.

def bitvector_to_cards(vector):
  chars =
